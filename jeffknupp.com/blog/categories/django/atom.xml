<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: django | Hackers Gonna Hack]]></title>
  <link href="http://www.jeffknupp.com/blog/categories/django/atom.xml" rel="self"/>
  <link href="http://www.jeffknupp.com/"/>
  <updated>2012-07-10T06:02:38-04:00</updated>
  <id>http://www.jeffknupp.com/</id>
  <author>
    <name><![CDATA[Jeff Knupp]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[From Memcached to Redis to Surpdb]]></title>
    <link href="http://www.jeffknupp.com/blog/2012/03/05/from-redis-to-memcached-to-surpdb/"/>
    <updated>2012-03-05T02:21:00-05:00</updated>
    <id>http://www.jeffknupp.com/blog/2012/03/05/from-redis-to-memcached-to-surpdb</id>
    <content type="html"><![CDATA[<p>In this post, I'll describe my journey to find the perfect caching solution for my Django-based site <a href="http://www.linkrdr.com">linkrdr</a>.  After trying Memcached and Redis, I settled on <strong>surpdb</strong>. I guarantee you haven't heard of surpdb before, because I just finished writing it.</p>

<!--more-->


<p>Querying and retrieving large datasets is not the Django ORM's sweet-spot. There are a number of reasons why Django's QuerySets struggle with large amounts of data, but the primary reason is <em>because it wasn't designed to work in that way</em>. For linkrdr, retrieving and analyzing a user's data became too much for all previous attempts at marrying Django QuerySets with some form of caching. Caching in Memcached to avoid going to the database on subsequent calls worked well except in one regard: the first request took so long that it would time out, resulting in a user never being able to see their data.</p>

<p>Enter Redis. Current sweetheart of the NoSQL movement, Redis is a key-value store that resides entirely in resident memory. In addition to simple strings, values can take the form of a number of Redis's native types: list, set, hash, etc. Redis is able to optimize on space for a number of these types, though there still is (sometimes significant) overhead for storing large numbers of small objects.</p>

<p>Installing Redis was easy. I headed over to the <a href="http://redis.io/">Redis site</a> and followed the installation instructions.  Since it's written in C, it requires a quick compilation (so make sure you have gcc installed) and you're ready to go. I changed the default <code>redis.conf</code> in the top-level directory and set <code>daemonize yes</code> so that redis would run in daemon mode. After that, a simple <code>./src/redis-server redis.conf</code> started a new redis daemon listening on the default ports.</p>

<p>But how was I going to make Redis any more useful than Memcached? I needed to rethink my entire strategy when it came to structuring my data. The Django ORM encourages good database normalization. Usually, this is helpful for all the reasons that database normalization is a <em>good thing</em>. Because of this, however, determining the links a user should see in their list of links to read required joining across four very large tables and returning a hierarchy of objects three levels deep.</p>

<p>I took a deep breath and began to rethink my data strategy. While the normalized structure was useful for inserting and updating records, <em>it poorly modeled the data I actually needed to return to the user.</em> I decided that I would create a new type of object which would live only in the Redis cache. It was a denormalized version of my <code>Link</code> model that additionally contained all of the fields from other models needed to display the data to the user. In this way, I would be querying Redis (not my Postgresql database) for an object that already had all of the data I needed. To the <code>Link</code> model I added a <code>to_dict()</code> function that returned a dictionary of the data I needed. This was saved directly in a Redis <code>hash</code> object using the <code>Link</code>'s id as the primary key.</p>

<p>Even then, however, I wasn't done. Redis was taking about 350MB to store my 560,000 Links. Since I use a <a href="http://www.linode.com/?r=ae1808f234f8e219de24842336fada09ef81d52f">Linode server</a>, for which physical memory is always at a premium, to host linkrdr, this was less than ideal. When I looked at the size of Redis's backup file, I was dismayed to see it was only 163MB. This meant that over 50% of the space needed to store my data was Redis overhead, since if it can be stored in a 163MB file it can theoretically be stored in memory using that amount of space. Some back-of-the-envelope calculations showed even 163MB was far more space than my data should require. I should make one thing very clear: this isn't Redis's fault. Though I tried my best to optimize my data structure according to the Redis optimization guidelines, Redis was not designed from scratch to store and retrieve <em>my</em> data structure as efficiently as possible.</p>

<p>But what if something <em>was</em> designed from the ground up to store my data structure? I may only be a journeyman web programmer, but I've been dealing with these types of design issues in C and C++ for my entire professional life. Having previously optimized a Django view using C++, I was comfortable with the interaction between Python and C++. I decided I would write my own NoSQL db according to <em>my</em> requirements. And surpdb was born.</p>

<p>surpdb (<strong>SU</strong>per <strong>R</strong>eliable <strong>P</strong>ython <strong>D</strong>ata<strong>B</strong>ase) was built with a single goal in mind: minimize both retrieval time and memory usage for <em>my</em> data. Since I was only supporting storing data from Python, I could specialize the internal data structures to store Python objects rather than some abstract type. In addition, since I knew the surpdb instance would be running on the same machine as the Python code querying it, I could use shared memory for communication. This was attractive for a number of reasons. With shared memory, I didn't have to pay the cost associated with serializing an object, sending it over the wire, and deserializing and storing it. Rather, the Python process would store the object in a shared memory queue that surpdb would be watching. surpdb would then pick up the message and store it directly as a native Python object in its own shared memory datastore. Using shared memory both for storage and communication also meant that I didn't need to give much thought to data backup. Since shared memory segments in Linux are represented as memory mapped files with a lifetime outside of that of the process that created them, the kernel would be responsible for asynchronously flushing my data to disk. In the event that surpdb crashed, recovery would be almost instantaneous as the snapshot of the database's address space before the crash was sitting there waiting to be attached to.</p>

<p>In surpdb, lookups are O(1) as one would expect. There is <em>very</em> little overhead for storing objects. In fact, due to the fact that I'm working with my own data, surpdb actually stores objects in <em>less</em> space than they would take in memory on their own. Since I know most of my data structure is storing different URLs, I'm able to precache lookup tables of common substrings and simply store an index on the object in memory. This saves a <em>drastic</em> amount of space. I was able to store my 560,000 Link objects in only <em>13MB</em>. That's an order of magnitude gain on Redis by specializing for my data. More importantly, it means the site can grow quite large without me needing by upgrade my Linode with more RAM.</p>

<h2>Update: Some Technical Details</h2>

<p>A number of people have asked what data structure I'm using for hashing.  The answer: none. As of an hour ago (when I realized I could do this), I removed the vector of pointers I was using and now rely on the integer key's value as an offset into shared memory (since my allocator guarantees all allocations are in contiguous memory). String storage is aggresively optimized (again, for my data). Domain names are stored in a separate table and the remaining portion of the string is compressed. Non-url strings are stored using LZMA compression. The obvious speed tradeoff here was acceptable to me as I'm not responsing to thousands of requests a second.</p>

<p>The end result of all of this is that I finally have a caching solution that meets my needs. Pages are dynamically generated in under a second even for thousands of links. I don't have to worry about more data requiring a machine upgrade (at least, not for a <em>very</em> long time). Also, I don't have to worry about upgrades, support, or learning the tricks of a new cache. I'm intimately familiar with the inner workings of surpdb (which make sense since I wrote it) and can optimize as I go. Lastly and most importantly, I no longer have to worry about the linkrdr infrastructure and can focus on improving the user experience.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Django Memcached: Optimizing Django Through Caching]]></title>
    <link href="http://www.jeffknupp.com/blog/2012/02/24/django-memcached-optimizing-django-through-caching/"/>
    <updated>2012-02-24T09:00:00-05:00</updated>
    <id>http://www.jeffknupp.com/blog/2012/02/24/django-memcached-optimizing-django-through-caching</id>
    <content type="html"><![CDATA[<p>Caching is a subject near and dear to the heart of many
peformance-minded programmers. For those coming to web programming
without other programming experience, caching may be a new topic. For
programmers new to the web, using an external cache may be an approach
not yet considered. In this post, I'll describe how, through the use of Django's caching support, I was able to <strong>reduce <a href="http://www.linkrdr.com">linkrdr's</a> page load time from over 3.5 seconds to 0.01 seconds.</strong></p>

<!--more-->


<h2>What is Caching?</h2>

<p>Caching is a word that changes meaning a bit depending on the context in which it's used, but in the general sense, <em>caching is the process by which the result of previous computation is saved and reused without re-performing the computation.</em> In the Django specific sense, there are three different types of caching:</p>

<ol>
<li><p><strong>The per-site cache</strong>: Saves the result of requests to all URLs
for reuse when a request for the same URL is later made.</p></li>
<li><p><strong>The per-view cache</strong>: Saves the result of requests resolving to
specified views for reuse when a request resolving to the same
view is made.</p></li>
<li><p><strong>The low-level cache API</strong>: Used by the developer to set, retrieve, and maintain objects in the cache manually.</p></li>
</ol>


<p>While the first two methods are certainly useful for some sites, the third is the most interesting. Caching requires some backend cache (obviously), and Django ships with a few out of the box. It can keep the cache in memory (not particularly useful when new threads are spawned for HTTP requests by the HTTP server), in the database (fine but slow), or on the filesystem (ditto).</p>

<p>Then there's <a href="http://memcached.org">Memcached</a>. Memcached is pretty well known in the web development community as an extremely flexible, scalable, and resilient external caching solution. The fact that Django ships with a "low-level" API for interacting with Memcached is great, although it does require the installation of a Python/Memcached interface package, of which there are two: python-memcached and pylibmc. Let's investigate using Memcached via a case study.</p>

<h2>Case Study: linkrdr.com Page Load Time Optimization</h2>

<p>I've talked about <a href="http://www.linkrdr.com">linkrdr's</a> optimization
techniques before. The main view shows links from entries in a
user's subscribed feeds. These links have been aggregated and sorted according to a ranking algorithm. For example, if a user subscribes to 10 RSS feeds and follows a few Twitter users and 4 of those sources mention a particular link, that link should appear higher in your list of links to read than a link from a single feed entry.</p>

<p>Retrieving, analyzing, aggregating, and sorting all of the links from all of the entries from all of a user's subscribed feeds is computationally expensive. The calculation of a link's "importance" was optimized by <a href="http://www.jeffknupp.com/blog/2012/02/15/optimizing-django-views-with-c-plus-plus/">rewriting the calculation in C++ and calling it from the view</a>. The database query <a href="http://www.jeffknupp.com/blog/2012/02/14/profiling-django-applications/">was similarly optimized</a>. These proved not to be enough, however, in the face of a flood of new users (and new data) to linkrdr.</p>

<p>3.5 seconds. That was how long it took to generate the data within the
main view function. Previously, it had been under a second, but after a
sudden flood of users and data, things had gotten out of control. I knew that I needed to implement caching to cut down page load time, but there were a few wrinkles. First, the datasets linkrdr returns are rather large, even with pagingation reducing the items shown to 100 per page. Second, a link had two real scores: one that could be calculated just by inspecting the link's properties in isolation and one that could only be calculated with respect to <strong>all</strong> the other links in a user's feed. These issues combined led to an interesting optimization problem.</p>

<p>The first goal was to cache all the user's sorted links whenver a
request came in, to be used in subsequent requests. I originally tried
to cache the entire result set like so:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Caching the results  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">results</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">user</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
</span><span class='line'><span class="k">if</span> <span class="ow">not</span> <span class="n">results</span><span class="p">:</span>
</span><span class='line'>    <span class="n">results</span> <span class="o">=</span> <span class="n">do_a_ton_of_work</span><span class="p">()</span>
</span><span class='line'>    <span class="n">cache</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">user</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">results</span><span class="p">)</span>
</span><span class='line'><span class="c"># ...</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Each time I tried this the results weren't added to the cache. After about 15 minutes of digging, I realized that the dataset was larger than memcached's limit for record sizes. When that happens, the call to <code>cache.set()</code> (maddeningly) fails silently.</p>

<p>So I couldn't cache the whole thing, but this turned out to be a useful
exercise. I realized I didn't need to cache the entire set as one big value. I could chunk the dataset in the same size chunks as were being paginated (currently 100 links). So now, the code looks like this:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Caching chunks  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">get_page</span><span class="p">(</span><span class="n">request</span><span class="p">)</span> <span class="c"># for pagination</span>
</span><span class='line'>
</span><span class='line'><span class="n">results</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">user</span><span class="o">.</span><span class="n">id</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">page</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="mi">100</span><span class="p">))</span>
</span><span class='line'><span class="k">if</span> <span class="ow">not</span> <span class="n">results</span><span class="p">:</span>
</span><span class='line'>    <span class="n">results</span> <span class="o">=</span> <span class="n">do_a_ton_of_work</span><span class="p">()</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">),</span> <span class="mi">100</span><span class="p">)</span>
</span><span class='line'>        <span class="n">cache</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">user</span><span class="o">.</span><span class="n">id</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="n">results</span><span class="p">[</span><span class="n">index</span><span class="p">:</span><span class="n">index</span><span class="o">+</span><span class="mi">99</span><span class="p">])</span>
</span><span class='line'><span class="c"># ...</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h2>Cache Eviction</h2>

<p>One thing to remember is that caches are not some magical never-ending source of storage. Memcached stores items in memory, of which it has a limited supply (limited by you, that is). When a cache is using the full amount of memory allotted and gets a request to add something new, a choice has to be made. This choice is known as the cache's <em>eviction policy</em>, since a record is about to be 'evicted' from the cache. Memached uses a variant of LRU, or Least Recently Used, eviction. Glossing over the topic of page allocation and sizing, which you can read about on Memcached's wiki, the cache looks for the least recently used item and overwrites it with the new value. This approach has good <em>temporal locality</em>, since something that was used recently (especially in web programming), is likely to be used again soon. Things not used for a while are less likely to be used again soon, and thus are good candidates to remove from the cache. For linkrdr, this has a few useful side effects. The view's cached items are likely to be used soon after they are created (as a user browses their links) and then not used at all (when they leave the site), which perfectly matches the cache eviction policy. Also, using small chunks instead of the whole dataset allows eviction with more granularity, so a user's entire cache isn't lost all at once.</p>

<h2>Which is Nice, Except...</h2>

<p>But there are some problems with this approach. For one, the first (uncached) request still takes the full 3.5 seconds. The first request being the most important one, this is not ideal. Second, we have to deal with updates to the dataset that would require a recalculating of the scores of each of the links (for example, when a user adds a new feed or linkrdr is updating feed items). Using some additional features of Memcached, we can overcome these obstacles as well.</p>

<p>Let's deal with updates to the dataset first. Django supports "versioning" of cache records. If you specify a version number in your <code>cache.set(key, value, version=my_version)</code> call, then a corresponding <code>cache.get(key, version=some_other_version)</code> call will not return any data. Using versioning, we can change things around and store the user's current 'version' in the cache. When we want to get the cached dataset, we specify the user's cached version number. In this way, we are able to <em>invalidate</em> old cache entries without searching through the cache for all of a user's cached items. An example will help clarify:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Memcached with versioning  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">version</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">user</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
</span><span class='line'><span class="k">if</span> <span class="ow">not</span> <span class="n">version</span><span class="p">:</span>
</span><span class='line'>    <span class="n">version</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'>    <span class="n">cache</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">user</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">version</span><span class="p">)</span>
</span><span class='line'><span class="n">page</span> <span class="o">=</span> <span class="n">get_page</span><span class="p">(</span><span class="n">request</span><span class="p">)</span> <span class="c"># for pagination</span>
</span><span class='line'>
</span><span class='line'><span class="n">results</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">user</span><span class="o">.</span><span class="n">id</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">page</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="mi">100</span><span class="p">),</span> <span class="n">version</span><span class="o">=</span><span class="n">version</span><span class="p">)</span>
</span><span class='line'><span class="k">if</span> <span class="ow">not</span> <span class="n">results</span><span class="p">:</span>
</span><span class='line'>    <span class="n">results</span> <span class="o">=</span> <span class="n">do_a_ton_of_work</span><span class="p">()</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">),</span> <span class="mi">100</span><span class="p">)</span>
</span><span class='line'>        <span class="n">cache</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">request</span><span class="o">.</span><span class="n">user</span><span class="o">.</span><span class="n">id</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="n">results</span><span class="p">[</span><span class="n">index</span><span class="p">:</span><span class="n">index</span><span class="o">+</span><span class="mi">99</span><span class="p">],</span> <span class="n">version</span><span class="o">=</span><span class="n">version</span><span class="p">)</span>
</span><span class='line'><span class="c"># ...</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Now, when a user adds a feed and the link scores need to be recalculated, we can simply increment his or her version so that the next <code>cache.get()</code> will be a cache miss.</p>

<p>But wait, I just said we <em>want</em> a cache miss. That can't be right. What we'd <em>really</em> like is for the links to be recalculated <em>and cached</em> and the old values invalidated. To accomplish this without interrupting the user (remember recalculating takes a couple seconds), we fire off a Celery task to ansynchronously recalculate the results, update the cache, and update the user's version. This way, the user can continue using the site and, if they take longer than 3-4 seconds between adding a feed and looking at their new links, we'll have the results <em>prefetched</em>. The idea of prefetching is a powerful one, and it solves the other problem (the first visit to a page results in a cache miss) as well. When linkrdr updates the feeds, it also caches the results for frequent users of the site (which it determines using yet more cached data). This way, the people who use the site the most experience instant page loads. Infrequent users will experience at most one slow page load.</p>

<p>It would be nice if we could prefetch every user's data after every update, but linkrdr has neither the memory nor computing power to do this. In a way, this is a good thing, because throwing more hardware at a problem doesn't require much thought. Many of the interesting technical challenges linkrdr faces come about because of the constraints on memory and CPU availability. Since I'm running on a single VPS, I have to get a bit creative with some of my solutions. If I didn't have to consider these things, the site would likely be worse for it and would certainly be less interesting to work on. The current caching solution can scale with the site without straining resources too much.</p>

<p>The preceeding is <a href="http://www.linkrdr.com">linkrdr</a>'s current approach to caching. One interesting side note: I'm currently investigating running memcached in a distributed manner using the other VPS I use to host <a href="http://www.illestrhyme.com">IllestRhyme</a>. Since the latter site has far more spare CPU cycles, computation can be partially offloaded to the second machine and the results stored in a distributed cache (which Memcached and Django helpfully support out of the box). Aditionally, sprinkling in other types of caching (like file based caching) may make it possible to prefetch all data for all users.</p>

<p>Questions or comments on <em>Django Memcached: Optimizing Django Through Caching</em>? Let me know in the comments below. Also, <a href="http://www.twitter.com/jeffknupp">follow me on Twitter</a> to see all of my blog posts and updates.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Optimizing Django Views With C++]]></title>
    <link href="http://www.jeffknupp.com/blog/2012/02/15/optimizing-django-views-with-c-plus-plus/"/>
    <updated>2012-02-15T09:55:00-05:00</updated>
    <id>http://www.jeffknupp.com/blog/2012/02/15/optimizing-django-views-with-c-plus-plus</id>
    <content type="html"><![CDATA[<p>In my <a href="http://www.jeffknupp.com/blog/2012/02/14/profiling-django-applications/">previous post</a> I outlined the method by which one goes about profiling a Django application. I used a view from <a href="http://www.linkrdr.com">linkrdr</a> as an example. That view is responsible of aggregating, ranking, and sorting all of the links in a user's feeds (RSS, atom, Twitter, etc). The code from the post was an early, simplistic implementation of the view. I have, however, a much more robust scoring algorithm, written in Python, which I planned to used on the site.</p>

<p>You may have caught the word 'planned' in there. The algorithm turned out to be too slow. Rather, my Python implementation of the algorithm
was slower than what I deemed acceptable. After thinking of various architectural changes that could be made to solve the problem, I settled on a somewhat radical solution for a Django developer: <strong>I implemented the view in C++</strong>.</p>

<p>I realize that not every Django developer knows C++, nor should they, but those that do should realize it's a viable tool available when Python is just too slow. Eventually, you may get to a point where you can't really optimize your Python code any more. In this case, profiling will show that most of your time is spent in Python library calls. Once you hit that point, you've either written a horribly inefficient algorithm or you've got a problem not suited for Python.</p>

<p>When I realized I had hit that point with my view code, I panicked.
<em>'What more is there to do?'</em> I wondered. Then I rememberd a work
project where I had written some C++ code that interfaced with Python.
From a technical perspective, there was nothing stopping me from
implementing some aspects of my Django app in C++ (besides the fact
that it's <em>excruciating</em> to write in coming from Python). Since linkrdr
is a single-person project, there are no teammates who need to grok the
code. I'm free to implement it as I wish.</p>

<!--more-->


<h2>Setting Up</h2>

<p>Having written "pure" C++/Python interoperability code before, and not
wanting to see <code>Py_XDecRef</code> again, I decided I would use boost::python. To begin, I made sure I had the latest <a href="http://www.boost.org">Boost</a>
libraries and a recent version of gcc installed so I could use C++11
features, which really are rather nice. After building the newest
version of the boost::python library, I set out to learn how to actually
use the thing. It turned out to be incredibly easy.</p>

<p>boost::python wraps a number of Python datatypes for you: <code>object</code>
represents a generic Python object, <code>list</code> is a list, and so on. Since
Python is dynamically typed, there really aren't a whole lot of these.
'Everything is an Object' means that everything is a
boost::python::object and can be accessed in that way.</p>

<p>In addition to primitive and container type wrappers, boost provides a
clear and concise mechanism to make C++ classes and functions visible to Python. I had
a simple class in the code of my previous entry name <code>LinkScore</code>. It
was basically a C struct with a list of objects and an integer. The C++
code for it is:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>A simple C++ class  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">using</span> <span class="k">namespace</span> <span class="n">boost</span><span class="o">::</span><span class="n">python</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">class</span> <span class="nc">LinkScore</span>
</span><span class='line'><span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">LinkScore</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'>    <span class="n">LinkScore</span><span class="p">(</span><span class="k">const</span> <span class="n">object</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">link</span><span class="p">,</span> <span class="kt">int</span> <span class="n">score</span><span class="p">)</span> <span class="o">:</span> <span class="n">score_</span><span class="p">(</span><span class="n">score</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">links_</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">link</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">list</span> <span class="n">links_</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">score_</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>If you're thinking my data members should be private, guess what: I
don't care. That's part of the joy of working on code that only you will
use. You get to write it and use it however you want.</p>

<h2>The Details</h2>

<p>Anyway, the boost::python code to make this callable from Python is:
<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>boost::python code for Python interoperability  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">class_</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">LinkScore</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;(</span><span class="s">&quot;LinkScore&quot;</span><span class="p">,</span> <span class="n">init</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">object</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;())</span>
</span><span class='line'>    <span class="p">.</span><span class="n">def_readwrite</span><span class="p">(</span><span class="s">&quot;links&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">LinkScore</span><span class="o">::</span><span class="n">links_</span><span class="p">)</span>
</span><span class='line'>    <span class="p">.</span><span class="n">def_readwrite</span><span class="p">(</span><span class="s">&quot;score&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">LinkScore</span><span class="o">::</span><span class="n">score_</span><span class="p">);</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Really, it couldn't be more simple. The <code>&lt;Python.h&gt;</code> way of
accomplishing this involves setting a struct with like 40 values to
declare each class. I was happy to not have to bother with that.</p>

<p>The actual code for my view is a free function called <code>get_scores</code>.
Here's a brief snippet:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>C++ code to be called by my Django view  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">using</span> <span class="k">namespace</span> <span class="n">boost</span><span class="o">::</span><span class="n">python</span><span class="p">;</span>
</span><span class='line'><span class="k">using</span> <span class="n">namspace</span> <span class="n">std</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">class</span> <span class="nc">CompareObject</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="kt">bool</span>  <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">LinkScore</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">l</span><span class="p">,</span> <span class="k">const</span> <span class="n">LinkScore</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">l</span><span class="p">.</span><span class="n">score_</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">r</span><span class="p">.</span><span class="n">score_</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">};</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">list</span> <span class="n">get_scores</span><span class="p">(</span><span class="n">object</span> <span class="n">links</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">object</span> <span class="n">utility</span> <span class="o">=</span> <span class="n">import</span><span class="p">(</span><span class="s">&quot;links.utility&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">set</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">LinkScore</span><span class="p">,</span> <span class="n">CompareObject</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">seen_links</span><span class="p">;</span>
</span><span class='line'><span class="n">list</span> <span class="n">python_seen_links</span><span class="p">;</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">len</span><span class="p">(</span><span class="n">links</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">const</span> <span class="n">object</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">link</span> <span class="o">=</span> <span class="n">links</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>    <span class="n">LinkScore</span> <span class="n">score</span> <span class="o">=</span> <span class="n">LinkScore</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">score_link</span> <span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">links</span><span class="p">));</span>
</span><span class='line'>    <span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">seen_links</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">score</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">iter</span> <span class="o">!=</span> <span class="n">seen_links</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="c1">// Do stuff</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="c1">// Do other stuff</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// TODO: Optimize this</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">seen_links</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">seen_links</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">python_seen_links</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">return</span> <span class="n">python_seen_links</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>If you know C++ and Python, it's almost like reading a mix of the two.
The above, however, is valid C++ code and is the interface that Python
uses to call into my scoring library. To expose this function to Python,
all that's needed is <code>def ("get_score", get_score);</code> within a
<code>BOOST_PYTHON_MODULE</code> block, which names the module to be imported.</p>

<p>When I was done writing the C++ code, I compiled it using gcc and Boost's bjam build tool,
set my LD_LIBRARY_PATH to pickup libboost_python.so, and fired up a
shell from manage.py (well, a 'shell_plus' really). I used the cProfile
module to compare the C++ version of the view with the Python version of
the view. The results were satisfying: an 8x speedup with the C++
version.</p>

<p>To call the C++ code, I just needed to make sure the .so generated was
on my PYTHON_PATH. I could then <code>import</code> it like a normal Python
library. I added it to my views.py and ran my unit tests. After they
passed, I committed everything and put the new code through it's paces
on the development web server. The reponse time was noticably improved,
with the view being served seemingly instantaneously.</p>

<h2>Wrap Up</h2>

<p>I realize this is not an optimization option avaiable to everyone, but
it <em>is</em> an option. Python is a fantastic language and Django is a nice
framework. When you need raw speed for computationally expensive
procedures, though, nothing beats getting closer to the metal. Overall,
I'm quite happy with the results and how easy it was to implement. I
will refrain from writing any more C++ code for linkrdr unless
absolutely necessary. It's nice to know, however, that the option is there.</p>

<p>Questions or comments on <em>Optimizing Django Views With C++</em> ? Let me know in the comments below. Also, <a href="http://www.twitter.com/jeffknupp/">follow me on Twitter</a> to see all of my blog posts and updates.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Profiling Django Applications: A Journey From 1300 to 2 queries]]></title>
    <link href="http://www.jeffknupp.com/blog/2012/02/14/profiling-django-applications/"/>
    <updated>2012-02-14T09:33:00-05:00</updated>
    <id>http://www.jeffknupp.com/blog/2012/02/14/profiling-django-applications</id>
    <content type="html"><![CDATA[<p>In this post, I'll discuss profiling Django applications through a case
study in <a href="http://www.linkrdr.com">linkrdr's</a> code. Through the use of
profiling tools, I was able to reduce the number of database queries a
view was using from <strong>1300</strong> to 2.</p>

<h2>Introduction To Profiling</h2>

<p>At some point in most Django projects, some part of the application
becomes 'slow'. This doesn't have to be the case (more on that later),
but it's often the result of changes made without performance
in mind.</p>

<p>In the begining, this is actually a good thing: <strong>focus on
making it work first, then focus on making it fast</strong>. Of course, you
don't want to code yourself into a corner by writing code that "works"
but does so in a way that it will <em>never</em> be fast. Instead, you want to
keep performance in the back of your mind while implementing a solution
that makes sense.</p>

<p>Once you've proven your solution works through your automated tests
(<a href="http://www.jeffknupp.com/blog/2012/02/11/unit-testing-in-django/">You are using automated tests, right?</a>),
the next step is to make sure its performance is acceptable. Note that
I didn't say 'optimal'. <strong>Don't waste time making something faster than
it needs to be</strong>. This should be common sense but, once the optimization
bug bites, it's common for developers to go a bit off the deep end and
keep trying to find optimizations long after it's necessary.</p>

<!--more-->


<p>So you're solution works, but it's slower than what you've deemed
acceptable. What's the first step? For far too many developers, it's</p>

<ol>
<li>Fire up my editor</li>
<li>Take a look around</li>
<li>Guess what I think is causing slowness</li>
<li>Make a bunch of changes</li>
<li>Hope it got faster</li>
</ol>


<p>Wrong, wrong, wrong. If you take away one thing from the post, let this
be it: <strong>developers are notoriously bad at predicting performance
bottlenecks</strong>. People think, 'Well, I wrote it, so I should know what
could be causing slowness.' Instead of relying on faulty intuition, we should be relying on <em>data</em>.</p>

<p>Profiling is the process by which we accumulate data on the performance
of an application. This data can come in many forms, but usually is some
variation on reporting two things: the number of times a function or
line of code was executed and how much time it took to do so. For every modern
language there exist some form of profiling tools. Use them.</p>

<h2>A Case Study</h2>

<p><a href="http://www.linkrdr.com">linkrdr</a> allows, among other things, a user to
import their RSS/Atom/Twitter/Anything Else feeds and get an
inteligently laid out view of the <em>links</em> contained in their feeds. The
<code>show_items</code> view for linkrdr is responsible for retrieving the user's
current feeds, gathering the links from those feeds' entries, and
scoring, sorting, and aggregating the links for presentation.</p>

<p>When I first began work on the view, I did so with a unit test prewritten.
I needed to get that test working, so I did so in the simplest way possible. Here's what
the code looked like:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Intial show_items implementation  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">show_items</span><span class="p">(</span><span class="n">request</span><span class="p">):</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">feeds</span> <span class="o">=</span> <span class="n">Feed</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">users__id</span><span class="o">=</span><span class="n">request</span><span class="o">.</span><span class="n">user</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
</span><span class='line'><span class="n">seen_links</span> <span class="o">=</span> <span class="p">{}</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">LinkScore</span><span class="p">():</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">link</span><span class="p">,</span> <span class="n">score</span><span class="p">):</span>
</span><span class='line'>    <span class="bp">self</span><span class="o">.</span><span class="n">links</span> <span class="o">=</span> <span class="p">[</span><span class="n">link</span><span class="p">]</span>
</span><span class='line'>    <span class="bp">self</span><span class="o">.</span><span class="n">score</span> <span class="o">=</span> <span class="n">score</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="n">feed</span> <span class="ow">in</span> <span class="n">feeds</span><span class="p">:</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">feed</span><span class="o">.</span><span class="n">entry_set</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
</span><span class='line'>        <span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">entry</span><span class="o">.</span><span class="n">link_set</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
</span><span class='line'>            <span class="c"># determine score for link</span>
</span><span class='line'>
</span><span class='line'><span class="n">sorted_links</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">seen_links</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">score</span><span class="p">,</span>
</span><span class='line'>        <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">return</span> <span class="n">render_to_response</span><span class="p">(</span><span class="s">&#39;links/entries.html&#39;</span><span class="p">,</span> <span class="p">{</span><span class="s">&#39;links&#39;</span><span class="p">:</span> <span class="n">sorted_links</span><span class="p">,</span> <span class="p">},</span> <span class="n">context_instance</span><span class="o">=</span><span class="n">RequestContext</span><span class="p">(</span><span class="n">request</span><span class="p">))</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Simple, right? If someone asked you to write psuedo-code to perform this
task, I'm guessing it would look largely similar to this. Remember,
that's a good thing in the begining. We're focusing on correctness more
than performance.</p>

<p>This code turned out to be 'all right' in the performance department.
It eventually got on my nerves, though, becuase I knew it has a problem that experienced Django developers probably
spotted right away. Even though I was %99.99 percent sure I knew what
was slowing down this view, I approached optimizing this code the same
way I approach any optimization task. I began with profiling.</p>

<p>Profiling in Django is a little all over the map. There isn't really a
universally accepted solution, as you can tell by reading the
<a href="https://code.djangoproject.com/wiki/ProfilingDjango">Django wiki</a>. I've
been using
<a href="https://github.com/django-extensions/django-extensions">django-extensions</a>
for a while now, and it has a very nice profiling feature: <code>manage.py runprofileserver</code>. It starts the Django webserver with the (now unmaintained but still useful) <em>hotshot</em> profiler and writes a .prof profiling results file on every request.</p>

<p>So I fired up the profile server and navigated to my view. A .prof file
was added to my /tmp directory. To interpret it, I entered the Django
shell and did the following:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Reading the profiling stats  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">import</span> <span class="nn">hotshot.stats</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">stats</span> <span class="o">=</span> <span class="n">hotshot</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s">&#39;/path/to/file.prof&#39;</span><span class="p">)</span>
</span><span class='line'><span class="n">stats</span><span class="o">.</span><span class="n">sort_stats</span><span class="p">(</span><span class="s">&#39;time&#39;</span><span class="p">,</span> <span class="s">&#39;calls&#39;</span><span class="p">)</span> <span class="c"># sort the output based on time spent</span>
</span><span class='line'><span class="ow">in</span> <span class="n">the</span> <span class="n">function</span>
</span><span class='line'><span class="n">stats</span><span class="o">.</span><span class="n">print_stats</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span> <span class="c"># print the top 20 culprits</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>The result of this was as I expected:
<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Profiling output  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>In <span class="o">[</span>6<span class="o">]</span>: stats.print_stats<span class="o">(</span>20<span class="o">)</span>
</span><span class='line'>   557944 <span class="k">function </span>calls <span class="o">(</span>485997 primitive calls<span class="o">)</span> in 3.959 seconds&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;   Ordered by: internal <span class="nb">time</span>, call count
</span><span class='line'>   List reduced from 457 to 20 due to restriction &lt;20&gt;&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;   ncalls  tottime  percall  cumtime  percall filename:lineno<span class="o">(</span><span class="k">function</span><span class="o">)</span>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt; 1310    0.763    0.001    0.783    0.001 /home/illest/linkrdr/virtualenv/local/lib/python2.7/site-packages/django/db/backends/postgresql_psycopg2/base.py:42<span class="o">(</span>execute<span class="o">)</span>
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;68656/15272    0.485    0.000    1.099    0.000 /usr/lib/python2.7/copy.py:145<span class="o">(</span>deepcopy<span class="o">)</span>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;67792    0.173    0.000    0.173    0.000 /usr/lib/python2.7/copy.py:267<span class="o">(</span>_keep_alive<span class="o">)</span>
</span><span class='line'> 1310    0.152    0.000    0.155    0.000 /home/illest/linkrdr/virtualenv/local/lib/python2.7/site-packages/django/db/backends/postgresql_psycopg2/base.py:116<span class="o">(</span>_cursor<span class="o">)</span>
</span><span class='line'> 3818    0.136    0.000    1.294    0.000 /home/illest/linkrdr/virtualenv/local/lib/python2.7/site-packages/django/db/models/sql/query.py:223<span class="o">(</span>clone<span class="o">)</span>
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;10041/5020    0.109    0.000    0.544    0.000 /usr/lib/python2.7/copy.py:234<span class="o">(</span>_deepcopy_tuple<span class="o">)</span>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt; 2344    0.089    0.000    0.106    0.000 /home/illest/linkrdr/virtualenv/local/lib/python2.7/site-packages/django/db/models/base.py:275<span class="o">(</span>__init__<span class="o">)</span>
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;8838/7636    0.076    0.000    0.575    0.000 /home/illest/linkrdr/virtualenv/local/lib/python2.7/site-packages/django/utils/tree.py:55<span class="o">(</span>&lt;strong&gt;deepcopy&lt;/strong&gt;<span class="o">)</span>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;10258    0.067    0.000    0.072    0.000 /home/illest/linkrdr/virtualenv/local/lib/python2.7/site-packages/django/utils/datastructures.py:110<span class="o">(</span>__init__<span class="o">)</span>
</span><span class='line'> 1310    0.057    0.000    0.111    0.000 /home/illest/linkrdr/virtualenv/local/lib/python2.7/site-packages/django/db/models/sql/compiler.py:218<span class="o">(</span>get_default_columns<span class="o">)</span>
</span><span class='line'> 3654    0.053    0.000    1.816    0.000 /home/illest/linkrdr/virtualenv/local/lib/python2.7/site-packages/django/db/models/query.py:214<span class="o">(</span>iterator<span class="o">)</span>
</span><span class='line'> 3280    0.050    0.000    2.209    0.001 /home/illest/linkrdr/virtualenv/local/lib/python2.7/site-packages/django/db/models/fields/related.py:288<span class="o">(</span>__get__<span class="o">)</span>
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;21494/19090    0.046    0.000    0.356    0.000 /usr/lib/python2.7/copy.py:226<span class="o">(</span>_deepcopy_list<span class="o">)</span>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt; 5021    0.045    0.000    0.326    0.000 /usr/lib/python2.7/copy.py:306<span class="o">(</span>_reconstruct<span class="o">)</span>
</span><span class='line'> 1310    0.044    0.000    0.420    0.000 /home/illest/linkrdr/virtualenv/local/lib/python2.7/site-packages/django/db/models/sql/compiler.py:47<span class="o">(</span>as_sql<span class="o">)</span>
</span><span class='line'> 1310    0.040    0.000    0.069    0.000 /home/illest/linkrdr/virtualenv/local/lib/python2.7/site-packages/django/db/models/sql/query.py:99<span class="o">(</span>__init__<span class="o">)</span>
</span><span class='line'> 2620    0.037    0.000    0.099    0.000 /home/illest/linkrdr/virtualenv/local/lib/python2.7/site-packages/django/db/models/sql/compiler.py:749<span class="o">(</span>&amp;lt;lambda&amp;gt;<span class="o">)</span>
</span><span class='line'> 1310    0.037    0.000    0.846    0.001 /home/illest/linkrdr/virtualenv/local/lib/python2.7/site-packages/django/db/backends/util.py:31<span class="o">(</span>execute<span class="o">)</span>
</span><span class='line'> 3818    0.037    0.000    1.345    0.000 /home/illest/linkrdr/virtualenv/local/lib/python2.7/site-packages/django/db/models/query.py:751<span class="o">(</span>_clone<span class="o">)</span>
</span><span class='line'>10258    0.037    0.000    0.037    0.000 /home/illest/linkrdr/virtualenv/local/lib/python2.7/site-packages/django/utils/datastructures.py:105<span class="o">(</span>__new__<span class="o">)</span>
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>As you can see, psycopg2 is calling <code>execute</code> 1310 times, which is
causing all sorts of slowness. Execute, in case you didn't guess, is the
function that executes an SQL query against the database. My view was
making <strong>1310 database queries for a user with 4 feeds</strong>.</p>

<p>Well, now we know what the cause of the slowness is. The question is: how do we fix it? I began by activating the django-debug-toolbar,
which lets you view the number of SQL queries a page generates, among
many other useful things. I confirmed that the number of queries
reported was the same in the debug-toolbar and went about optimizing the
code.</p>

<p>The first approach to optmization in Django should always be to modify the
problematic function without changing anything else. Sometimes, you won't be
able to optimize without making changes to your models or other parts
of your application, but this kind of change shouldn't be your first
inclination.</p>

<p>So I went back to my view and asked: is there a better way to get the same
data I'm currently getting? It turns out there is: using <code>select_related</code> in my query.
<a href="https://docs.djangoproject.com/en/1.1/ref/models/querysets/#select-related">select_related</a> populates your QuerySet with the records you requested
plus related records based on ForeignKeys in your model. If I could
change my query to use select related, I could drastically reduce the
number of queries the view required.</p>

<p>There was an issue, though. My models were set up so that a Link
belonged to an Entry, which belonged to a Feed, which had a set of
Users associated. I had gone from the top down: a query filtering feeds
that belonged to the current user. What I needed to do to realize the
benefit of <code>select_related</code> was to get all of the objects I needed in
one query. Since what I really needed was <code>Link</code> objects, I changed the
query to:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Changing the query  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">links</span> <span class="o">=</span> <span class="n">Link</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">select_related</span><span class="p">(</span><span class="s">&#39;entry&#39;</span><span class="p">,</span> <span class="s">&#39;entry&lt;strong&gt;feed&#39;</span><span class="p">,</span> <span class="s">&#39;url&#39;</span><span class="p">,</span> <span class="s">&#39;entry&lt;/strong&gt;url&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">entry</span><span class="o">&lt;</span><span class="n">strong</span><span class="o">&gt;</span><span class="n">feed</span><span class="o">&lt;/</span><span class="n">strong</span><span class="o">&gt;</span><span class="n">users__id</span><span class="o">=</span><span class="n">request</span><span class="o">.</span><span class="n">user</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>This would give me all of the links that I was interested in, plus all
of the related objects that I'd be using. I reran the view profiling and
saw something unexpected: I was still performing over 600 queries. Using
the debug-toolbar to determine the lines of code generating these
queries quickly revealed my error. When using <code>select_related</code>, you must
make sure to <em>reuse the QuerySet in subsequent code</em>. If you
accidentally use a new QuerySet (even if the objects would have been in
the original QuerySet) it will result in a new database query. This
cascades down to any other objects using the new QuerySet, and now you've
got the same issue again.</p>

<p>After making sure I reused the QuerySet throughout my view and the
functions it called, I reran the view using the debug-toolbar. Finally I
had the results I wanted: all of the data generated in just 2 queries
(the other query was the User's Session query, which can't really be
avoided). One thing you need to be aware of when using <code>select_related</code>
is that the query can get so large as to be slower than the iterative
approach. That's something I'll definitely need to keep an eye on in the
future.</p>

<h2>Cleaning Up</h2>

<p>After re-running the tests to confirm my new code worked as expected and
committing the code to git, I had one more task left: update my unit
tests to reflect my new changes. While I didn't make any functional
changes, I did make performance changes, and <strong>performance changes
should be unit tested just like functionality changes</strong>.</p>

<p>Helpfully, Django's <code>TestCase</code> class has an assertion <code>TestCase.assertNumQueries()</code>
that checks the number of queries performed during a test. I simply
added this assertion the my view test and I was done. This prevents me
from adding code in the future that increases the number of database
queries without forcing myself to decide if that's acceptable.</p>

<p>Questions or comments on <em>Profiling Django Applications</em>? Let me know in the comments below. Also, <a href="http://www.twitter.com/jeffknupp">follow me on Twitter</a> to see all of my blog posts and updates.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unit Testing in Django]]></title>
    <link href="http://www.jeffknupp.com/blog/2012/02/11/unit-testing-in-django/"/>
    <updated>2012-02-11T14:17:00-05:00</updated>
    <id>http://www.jeffknupp.com/blog/2012/02/11/unit-testing-in-django</id>
    <content type="html"><![CDATA[<p>As a follow-up to my post <a href="http://www.jeffknupp.com/blog/2012/02/09/starting-a-django-project-the-right-way/">Starting a Django Project the Right Way</a>, I wanted to talk aboue the importance of writing tests for Django applications. I previously mentioned that my first site <a href="http://www.illestrhyme.com">IllestRhyme</a>, has no app specific tests for it. This is both embarassing and true. I've lost countless hours to fixing problems caused by new changes. I wasn't going to make the same mistake with <a href="http://www.linkrdr.com">linkrdr</a>. Having a set of unit tests that I can run in an automated fashion has made a world of difference.</p>

<p>The Django <code>unittest</code> framework (really the Python <code>unittest</code> framework) is both simple and powerfull. Along with the test client (<code>django.test.client.Client</code>), there's a lot you can
do with Django right out of the box.</p>

<h2>Setup</h2>

<p>To start, we'll want to create a dump of our database data to use during testing.</p>

<p><code>bash Dump our data
$ ./manage.py dumpdata --format=json &gt; my/app/directory/initial_data.json
</code></p>

<p>This will give us a json <a href="https://code.djangoproject.com/wiki/Fixtures">fixture</a> that mimics the current state of our production database. Note that since this is a fixture for <em>all</em> of the apps installed, we've put it in a non-standard directory. To let the test runner find our fixture, we'll need to set <code>FIXTURE_DIRS</code> to the directory we just dumped our data to.</p>

<p>Now that we have our data copied, let's run whatever tests our installed
apps have already:</p>

<p><code>bash Run our tests
$  python manage.py test
</code></p>

<p>This hopefully gives us output like:</p>

<p>``` bash Test run output</p>

<pre><code>.....................................................................................................................................................................................................................................................................................................................................................................
</code></pre>

<hr />

<pre><code>Ran 357 tests in 30.025s

OK
</code></pre>

<p>```</p>

<p>This is also a good check of the integrity of your database, as Django
will try to load a fixture representing all of your data. If you've been
screwing around with the admin interface or the shell adding
and deleting records, you may have integrity errors. If you do (like I
did), you'll have to fix them manually and re-dump your data.</p>

<!--more-->


<p>Once we've got the tests for other apps working, it's time to write our
own. They'll generally all follow the same pattern:</p>

<ol>
<li>Create a class deriving from django.test.TestCase</li>
<li>If necessary, add a setUp function to prepare data for the tests</li>
<li>Implement test functions with a name starting with 'test'</li>
<li>Run the tests</li>
</ol>


<p>You should get in the habit of running the tests after each test you
create. Sometimes, you'll write a test expecting it to pass but it will
highlight an issue in your code. If you go off and fix the issue without
running the tests again afterwards, you may have unwittingly made
another test fail with your fix.</p>

<p>We'll be using <code>django.test.TestCase</code> as the base class for our tests
instead of Python's <code>unittest.TestCase</code> because the Django version adds
(from the documentation):</p>

<ol>
<li>Automatic loading of fixtures</li>
<li>Wrap each test in a transaction</li>
<li>Create a TestClient instance</li>
<li>Django-specific assertions for testing for things like redirection and form errors</li>
</ol>


<p>One quick thing to note: <em>all of your test functions names must begin with
'test'</em>. If you've never used Python or Django's unittest before, you
will be <strong>extremely</strong> frustrated when you define your test classes and
functions, then run the tests only to have nothing happen. There's a
practical reason for this decision (so you can create regular functions in your
TestCase derived class), but it drives new users insane.</p>

<h2>Adding a Test</h2>

<p>Time for an example. <a href="http://www.linkrdr.com">linkrdr</a> needs to be able to look-up a URL and
determine if it's actually a feed. Here's a simplified version of the
code I wrote to do that:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Simple feed checker  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">link_types</span><span class="o">=</span> <span class="p">[</span><span class="s">&#39;application/atom+xml&#39;</span><span class="p">,</span> <span class="s">&#39;application/rss+xml&#39;</span><span class="p">,</span>
</span><span class='line'><span class="s">&#39;application/rdf+xml&#39;</span><span class="p">,</span> <span class="s">&#39;application/xml&#39;</span><span class="p">]</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">def</span> <span class="nf">is_feed</span><span class="p">(</span><span class="n">url</span><span class="p">):</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">link_type</span> <span class="o">=</span> <span class="n">urllib2</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">url</span><span class="p">)</span><span class="o">.</span><span class="n">info</span><span class="p">()</span><span class="o">.</span><span class="n">gettype</span><span class="p">()</span>
</span><span class='line'><span class="k">return</span> <span class="n">link_type</span> <span class="ow">in</span> <span class="n">link_types</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Simple, right? Let's add a test for it. First we'll remove anything
hanging around in tests.py (like the initial contents) and start with a
clean file. We're going to create a class that derives from
<code>unittest.TestCase</code>. I'll call mine <code>IsFeed</code> so I know from the name
what functionality it's testing.</p>

<p>So far we have (with the required imports)</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Our tests so far  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">from</span> <span class="nn">django.utils</span> <span class="kn">import</span> <span class="n">unittest</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">class</span> <span class="nc">IsFeed</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Now, we'd like to actually add some tests to our test case. Let's check
to make sure my blog's atom feed is recognized as a valid feed:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Adding a test  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">from</span> <span class="nn">django.utils</span> <span class="kn">import</span> <span class="n">unittest</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">class</span> <span class="nc">IsFeed</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="s">&quot;&quot;&quot;Tests the functionality of utility.is_feed</span>
</span><span class='line'><span class="s">by getting various well-known good feeds and</span>
</span><span class='line'><span class="s">making sure they validate&quot;&quot;&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">test_is_feed_atom</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'><span class="sd">&quot;&quot;&quot;Is the url a valid feed?&quot;&quot;&quot;</span>
</span><span class='line'>    <span class="n">url</span> <span class="o">=</span> <span class="s">&#39;http://www.jeffknupp.com/atom.xml&#39;</span>
</span><span class='line'>    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="n">utility</span><span class="o">.</span><span class="n">is_feed</span><span class="p">(</span><span class="n">url</span><span class="p">))</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>You'll notice that I documented the test case, and you may be wondering
why, since I'm a lone developer. Two reasons. First, documentation is
just as useful for yourself as it is for others. Invariably, you'll come
back to code you wrote a while ago and decide you were drunk while you
wrote it. It just makes no sense. Having documentation helps in that
respect.</p>

<p>The second reason is more subtle: to prepare to open-source the project.
My goal is to eventually open-source almost all linkrdr that isn't
essential to the site. Anyone can write a function to check if a URL is
an RSS or atom feed. It would be nice to have one, though, that's been
through a lot of use and checks for odd corner-cases. To that end, I'm
attempting to keep all of linkrdr PEP8 and PEP257 compliant. It's a bit
more to write, but I'll be glad I did once I release it into the wild.</p>

<p>Anyway, back to our tests. We should now be able to run the tests using:</p>

<p><code>bash
$  python manage.py test &lt;appname&gt;
</code></p>

<p>and get output similar to when we ran the testcases before.</p>

<h2>Code Coverage</h2>

<p>Tests are all well and good, but if you aren't testing a vast majority
of your code, they're just a false sense of security. Code coverage
tools are designed to intrument your test runs and determine what parts
of your tested code were actually exercised. With code coverage tools,
saying your code is 100% tested is not matter of opinion but rather a provable fact.</p>

<p>I use coverage.py for my code coverage. You can install it using pip via
<code>pip install coverage</code>. Once it's installed, rerun your tests like so:</p>

<p><code>bash Running coverage.py with unit tests
$  coverage run manage.py test
</code></p>

<p>This will produce an instrumentation file that you can convert to HTML
or LaTex, or view from the command line. Run</p>

<p><code>bash Viewing coverage reports
$  coverage report
</code></p>

<p>to get a snapshot of how much of your code is actually being tested by
your unit tests.</p>

<h2>More to Come</h2>

<p>I plan on continuing describing best practices for professional Django
development, started in <a href="http://www.jeffknupp.com/blog/2012/02/09/starting-a-django-project-the-right-way/">Starting a Django Project the Right Way</a> in future posts. Next time I'll discuss the TestClient and integrating tests into your deployment system.</p>

<p>Questions or comments on <em>Unit Testing in Django</em>? Let me know in the comments below. Also, <a href="http://www.twitter.com/jeffknupp">follow me on Twitter</a> to see all of my blog posts and updates.</p>
]]></content>
  </entry>
  
</feed>
