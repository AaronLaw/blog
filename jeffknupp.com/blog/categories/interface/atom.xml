<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: interface | Hackers Gonna Hack]]></title>
  <link href="http://www.jeffknupp.com/blog/categories/interface/atom.xml" rel="self"/>
  <link href="http://www.jeffknupp.com/"/>
  <updated>2012-07-10T06:02:38-04:00</updated>
  <id>http://www.jeffknupp.com/</id>
  <author>
    <name><![CDATA[Jeff Knupp]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Coding Backwards]]></title>
    <link href="http://www.jeffknupp.com/blog/2012/02/07/coding-backwards/"/>
    <updated>2012-02-07T09:55:00-05:00</updated>
    <id>http://www.jeffknupp.com/blog/2012/02/07/coding-backwards</id>
    <content type="html"><![CDATA[<p>At my real job I've been working in my spare time on a large-scale Python testing framework. When I decided our current framework didn't meet our needs, I took a new approach (for me) to developing software: <em>coding backwards</em>. Since doing so, I've learned that coding backwards can, <em>but not will</em>, lead to the creation of some fabulous APIs.</p>

<p>The idea for coding backwards was most clearly verbalized for me by
Aaron Swartz and his <a href="http://webpy.org">web.py</a> framework. He says:
<blockquote><p>I wrote a web application in Python just imagining how I wanted the API<br/> to be. It started with import web, of course, and then had a place to<br/> define URLs, simple functions for GET and POST, a thing to deal with<br/> input variables and so on. Once the code looked right to me, I did<br/> whatever it took to make it execute without changing the application<br/> code -- the result was web.py.</p></blockquote></p>

<p>This was a revelation for me. When you're building software for others
to use, <strong>make it as natural as possible for them to do so</strong>. I call
this <em>coding backwards</em>. It directly influenced how I built my testing
framework.</p>

<p>I started with the finished product: a test script written in Python. I
wrote valid Python code against a library that didn't exist yet. Without
an existing API to get in my way, I was able to express my intentions
clearly. Anyone reading the test script would immediately know what was
happening. More importantly, they wouldn't be exposed to weird
implementation quirks. It was my version of the "optimal" test script for our system in Python.
After writing that script, there was only one problem: it didn't
actually do anything yet.</p>

<p>From the test script, I created the classes and functions that the test
script called. What I did within the library was less important than
<em>not changing the test script to fit the library</em>. If I have to make a
few weird implementation decisions as a result, fine. The point is,
<strong>users are going to use the library's API, not the library's
internals</strong>. Of course, that doesn't mean the implementation can be
spaghetti coded crap. It must be implemented professionally, just with
making the test script work as expected the primary goal.</p>

<p>Coding backwards prevents you from writing functionality that no one
will use, because someone is already using all of your library. That
keeps the interfaces tight and well defined. With something like a
testing framework, the interface is king. The ratio of test case writers
to test framework maintainers will be something like 10:1, so creating a
friendly, usable interface is key.</p>

<p>In actually writing the implementation, I found myself bouncing around
between the top level interface code and the lowest level library code
quite a bit. I would create a top level class or function, realize it
would need to call some library code, then go off and write that library
code. Again, though, I was coding backwards. I didn't start off writing
a bunch of low level libraries I thought I would need. I deferred
creation of the libraries until I actually needed them.</p>

<p>This lends itself well to writing tests. At each point, you're writing
the minimum required to get the interface working. Sounds suspiciously
like the methodology for creating unit tests. In practice, writing tests
naturally fit into the development flow. This is most decidedly <em>a good
thing</em>.</p>

<p>While the framework isn't complete, it certainly is usable. What's more,
it usable by just about anyone without having to even look at the
interface. Since I created the test script first, I have a wonderful
example to show the library's canonical use. I've been quite happy with
the results of coding the framework backwards. It puts emphasis on the
interface rather than the implementation, which is exactly where the
emphasis should be in a testing framework.</p>

<p>Questions or comments on <em>Coding Backwards</em>? Let me know in the comments
below. Also, <a href="http://www.twitter.com/jeffknupp">follow me on Twitter</a> to see all of my blog posts and
updates.</p>
]]></content>
  </entry>
  
</feed>
