<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: git | Hackers Gonna Hack]]></title>
  <link href="http://www.jeffknupp.com/blog/categories/git/atom.xml" rel="self"/>
  <link href="http://www.jeffknupp.com/"/>
  <updated>2012-07-10T06:02:38-04:00</updated>
  <id>http://www.jeffknupp.com/</id>
  <author>
    <name><![CDATA[Jeff Knupp]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Building Your Second Django Site]]></title>
    <link href="http://www.jeffknupp.com/blog/2012/02/08/building-your-second-django-site/"/>
    <updated>2012-02-08T05:03:00-05:00</updated>
    <id>http://www.jeffknupp.com/blog/2012/02/08/building-your-second-django-site</id>
    <content type="html"><![CDATA[<p>I started work on my second Django powered site today. It's not
ready to be unveiled, but I've realized that, while your first site will
always be your baby, your second is where you start to hit your stride.</p>

<p>So what have I done differently? For one, <strong>testing</strong>. For
<a href="http://www.illestrhyme.com">IllestRhyme</a> I never wrote any tests, which
has caused me no end of troubles. Now that the site is stable and
actively used, it's difficult to make myself go back and write tests,
though I know I need to. The new site has unit tests for
everything, and though it's somewhat of a pain to do, it will most
certainly pay dividends in the long run.</p>

<p>In the production environment, everything is running
under <a href="http://pypi.python.org/pypi/virtualenv">virtualenv</a>, Python's unofficial answer to the problem of running multiple
Python environments. It effectively does a clean Python install to a local
directory and hijacks <code>pip</code> and <code>easy_install</code> commands to install
packages locally. This guarantees packages for the new site don't clash
with packages for the old site.</p>

<p>Also, I'm using <a href="http://www.fabfile.org">Fabric</a> for automating deployment tasks. While before I relied on a set of git hooks, this became a bit cumbersome. Fabric is fantastic for deployment. My fabfile backs up the site, downloads packages from git, creates symlinks, run South migrations, runs the tests, and reloads Apache. Deployment should really be a one-button-press activity. Fabric makes it easy. Thanks to a number of commenters (Alexis Bellido on this site, joelhaasnoot, spleeyah, jsvaughan, and marcofucci on Hacker News)  for pointing this out on a previous post.</p>

<!--more-->


<p>Still using Git as my DVCS, but now I've got 100s of commits to
a number of projects under my belt. This time around, git is a tool and
not a chore (the chore being actually learning it properly).</p>

<p>On the internals side, a lot of what I'm doing on the second site is in
pure Python (and some may eventually be in C++ libraries). Due to the nature of the site, storing everything in the
database would quickly lead to space issues, so much is generated
dynamically. For long-running tasks, I'm using
<a href="http://www.celeryproject.org">Celery</a> and <a href="https://github.com/ask/django-celery">django-celery</a>. They're a breeze to work with. Tasks in Celery are basically fire and forget and the interface stays out of your way.</p>

<p>If you were to look at my first site, you could almost tell the date a
file was written by reading the code. I was learning Django by doing,
and a lot of the early stuff is pretty rough. I've rewritten a lot of
it, but it's there. With the new site, I'm writing idiomatic Django (if there is such a thing)
from the start. Simple decisions like naming all of your views and
referring to them using <code>url my_view_name</code> were
made in the beginning, not halfway through the project when I first learned about them. After getting one large-scale Django site under your
belt, you should notice that the framework doesn't get in your way as
much. The boilerplate forms, views, and models come easy, leaving you
time and energy to work on the interesting stuff.</p>

<p>And it's the interesting stuff that should be the focus of your second
(personal) Django site. While a simple CRUD based application is a noble
goal for your first site, your second should push boundaries. My new
site has a whole host of interesting computational and optimization
problems, and those are fun to work on. Figuring out how to exclude a
field on a ModelForm for the first time is not.</p>

<p>One last thing. A number of people have asked me recently how difficult
it was to learn Django from scratch and take a site live, either out of
curiosity or because they've wanted to do the same thing. My answer:
the coding is easy; building something people want to use and getting
them to use it is hard. <em>Really hard</em>. It requires a totally different skill-set from
programming, but it's incredibly rewarding to even attempt. To anyone who's been toying
with the idea of launching a web site, as I had for years, I urge you to do so. The skills you
pick up in launching a site are invaluable and will positively impact
your career.</p>

<p>Questions or comments on <em>Building Your Second Django Site</em>? Let me know in the
comments below. Also, <a href="http://www.twitter.com/jeffknupp">follow me on Twitter</a> to see all of my blog posts
and updates.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Git with Django]]></title>
    <link href="http://www.jeffknupp.com/blog/2012/02/07/using-git-with-django/"/>
    <updated>2012-02-07T07:57:00-05:00</updated>
    <id>http://www.jeffknupp.com/blog/2012/02/07/using-git-with-django</id>
    <content type="html"><![CDATA[<p>When I started <a href="http://www.illestrhyme.com">IllestRhyme</a>, I had never used git . Git gives me distributed version
control and the ease (and speed!) of the git workflow for a slight learning
curve. Below is how I set up my Django project to use git, from start to
finish.</p>

<p>To begin, I had my Django project already created and a bit of code in
there, so I needed to "add" it to a new git repo. All that's needed for
this is to <code>cd</code> into the top level directory and run <code>git init .</code> This
sets up a git repo in the directory, <strong>but doesn't commit the files.</strong>
Before committing, we'll want to setup our <code>.gitignore</code> file to tell
git what files not to track in version control. Since I'm working with Python files using
vim, my <code>.gitignore</code> file has the following contents:</p>

<pre><code>*.pyc
*.swp
local_settings.py
</code></pre>

<p>The <code>local_settings.py</code> file is part of my development workflow, as
explained in <a href="http://www.jeffknupp.com/blog/2012/02/05/django-production-deployment-using-git/">this post</a>. After we create
the <code>.gitignore</code> file, we add <em>everything</em> to the repository, using <code>git
add .</code> This stages all of our files for commit to git. At this point, we
can run <code>git commit</code> to actually commit our files for the first time.</p>

<p>At this point, we have our Django project in a (local) git repository. I
use Bitbucket as a "backup" git repo in case I lose my web server. As
you might have guessed, I do all my work on the web server directly
using ssh, gvim, and X tunneling. This is not necessarily recommended
for large projects, but it works well for a single developer. Whenever I
make a change and commit it, I use <code>git push</code> to push the commit to
Bitbucket, so that Bitbucket always has the latest copy of the repo.</p>

<p>Once we've committed to git, the first thing to do is clone our
repository to create a development environment in a new area on our
machine reserved for development. If you're cloning on the
same machine, you'll use <code>git clone &lt;path/to/original/git/repo&gt;</code>. Github
or Bitbucket users will use <code>git clone &lt;remote repository&gt;</code>, where
"<remote repository>" is what the service shows is the URL for your repo. Regardless,
clone your repo to create a dev environment that exactly mirrors your
prod environment.</p>

<p>In our new development area, we'll first want to create a
branch, using <code>git branch &lt;branchname&gt;</code>. Git creates a branch of the
current branch (which for us will have been 'master'). <strong>It does not,
however, switch you to that branch.</strong> To switch to working on your new
branch, use <code>git checkout &lt;branchname&gt;</code>. To see what branches are
available, just type <code>git branch</code>. The branch you are currently on will
be marked with a '*'.</p>

<p>Once you've done some work on your branch that you're happy with, it's
time to commit. If you added files during this phase, run <code>git add
&lt;filenames&gt;</code> to stage them to be committed. Alternately, you can use
<code>git add .</code> to add <em>all</em> untracked files to be committed. From here,
just commit using <code>git commit &lt;changedfiles&gt;</code> or <code>git commit -a</code> for all
changed files that git is tracking.</p>

<p>Now it's time to merge your changes back into your master branch. Switch
back to the master branch with <code>git checkout master</code> and merge the
changes with <code>git merge &lt;branchname&gt;</code>. If there are no conflicts, <em>git
will autocommit the merge changes</em> and nothing more needs to be done. If
conflicts do arise, manually fix them and <code>git commit</code> them. Git will
prepopulate the commit message with something like 'Merge from
<branchname>', which you can replace or, better yet, enhance.</p>

<p>Now that we've got our changes committed to the master branch in our
development area, it's time to push them to production. If you're using
a service like Github or Bitbucket, first push the changes there with a
<code>git push</code>. Next, <code>cd</code> into your production area and pull down the
changes using <code>git pull</code> (or <code>git pull &lt;development repo area&gt;</code> for a
repo on the local machine). This should update the master branch in your
production area with all of the changes committed from development.
That's it! You've successfully used git to manage changes in a Django
project!</p>

<p>I'm certainly no git guru and there are likely aspects of this workflow
that can be enhanced or simplified. If you see something that doesn't
make sense or can be streamlined, please let me know in the comments.
I'm always looking to improve my git-Fu!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Django Production Deployment and Development Using Git]]></title>
    <link href="http://www.jeffknupp.com/blog/2012/02/05/django-production-deployment-using-git/"/>
    <updated>2012-02-05T21:11:00-05:00</updated>
    <id>http://www.jeffknupp.com/blog/2012/02/05/django-production-deployment-using-git</id>
    <content type="html"><![CDATA[<p>When I started <a href="http://www.illestrhyme.com">IllestRhyme</a>, I had never before managed a web application. Much was similar to enterprise development. Much wasn't. One of the things I had no idea about was how to manage production deployment of a web app. I settled on some common Django trickery and Git, and it has worked like a charm.</p>

<p>I knew going in that I would use Git for source control. I wanted a distributed version control system to give me an opportunity to work anywhere git was installed. I didn't suspect I would use git for deployment, also.</p>

<p>When the site began, I didn't even have a "deployment" strategy. There were so few visitors to the site that I could work on it live. Within two weeks, it was clear I couldn't be showing users HTML 500 errors as frequently as I had been. I needed to start acting like I was working on a "real" project.</p>

<p>(Re)Enter Git. <!-- more -->I would have a few mis-starts before I settled on a safe, productive way to work. Initially, I created a new directory on my machine for development. I cloned my git repository and created a dev branch. The dev branch had the same settings.py file as the master branch, and I was editing this manually as I switched between the dev and master branches. I knew this was a dangerous practice, and this proved true when I hosed the production database because of a bad settings file. Good thing I had DB backups...</p>

<p>There had to be a better way. I decided that, since the Django settings.py file was just Python, I would create a <code>localsettings.py</code> file that the settings.py file would import. For development, this would point to the development database and settings. For production, the production settings. This file is imported by the settings.py file and is not tracked by git (there's an entry for it in the .gitignore file).</p>

<p>Now I was free to work on my dev branch without worrying about messing up production. When I was happy with a change, it was merged with the master branch and pushed to bitbucket. Then the production area pulled down the changes and Apache was restarted. Perfect.</p>

<p>Something that took a bit to get used to using git was branching. In enterprise development with CVS or SVN, branches are more substantial "things" then personal development with git. A branch in git can both be created and deleted quickly. I frequently have five or six active branches of development for <a href="http://www.illestrhyme.com">IllestRhyme</a>: some for large sweeping changes that require database migrations, some just adding a few new pages/views to the site, some as small as correcting typos or adding a link or two.</p>

<p>Where git really shines is in switching between active branches. I can be working on a branch with 70 new files, say <code>git checkout &lt;somesmallbranch&gt;</code>, and everything is exactly as it should be, with the added files removed and the changes merged back to my small change branch. This allows me to work almost in real-time. If I'm deep in a change but get alerted to an error via email, I can quickly switch to my main dev branch, make a change, test it, commit it and pull it down in mere minutes.</p>

<p>Git has opened up a new world for me in terms of productivity. It's been so useful on IllestRhyme that I've begun to use it at my day job as an "out-of-band" VCS. I checkout with our enterprise VCS, do a quick <code>git add .</code> to my personal git repository, and branch/commit/merge to my heart's content. When I'm happy with my changes, I commit to my enterprise VCS, which has been instructed to ignore my .git directory.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setting Up Octopress/Jekyll with Apache]]></title>
    <link href="http://www.jeffknupp.com/blog/2012/02/02/setting-up-octopress-slash-jeckyll-with-apache/"/>
    <updated>2012-02-02T02:06:00-05:00</updated>
    <id>http://www.jeffknupp.com/blog/2012/02/02/setting-up-octopress-slash-jeckyll-with-apache</id>
    <content type="html"><![CDATA[<p>So now that I got my "Hello World" post out of the way, I think it would be instructive to describe the setup process for this blog. Octopress is exactly what I've been looking for: a well styled, static page based blogging engine that doesn't get in my way. The fact that Jekyll (on which Octopress is based) is so closely integrated with git is a definite plus. So how did the install go? First some background.</p>

<p>I'm the founder of <a href="http://www.illestrhyme.com">IllestRhyme.com</a>, a site where users post rap verses they wrote and other users comment/vote on them. There's a ton of other features, but that's the gist of it. Anyway, I run IllestRhyme on a <a href="http://www.linode.com/?r=ae1808f234f8e219de24842336fada09ef81d52f">Linode</a> server running Ubuntu. I use Apache for dynamic content and Lighttpd for static content. Since I already have a Linux machine on the Interwebs, I followed the <a href="http://octopress.org/docs/setup/">instructions</a> on my Linode machine... which is to say I basically copy and pasted the instructions:</p>

<pre><code>rvm install 1.9.2 &amp;&amp; rvm use 1.9.2
git clone git://github.com/imathis/octopress.git octopress
cd octopress    # If you use RVM, You'll be asked if you trust the .rvmrc file (say yes).
gem install bundler`
bundle install`
</code></pre>

<p>Everything went smoothly. Next I needed to make Apache serve both www.jeffknupp.com and www.illestrhyme.com. I created a new file in /etc/apache2/sites-available/ named 'jeffknupp.com' and added the normal VirtualHost settings. After running <code>sudo a2ensite jeffknupp.com</code> and reloading apache (<code>sudo service apache2 reload</code>), Apache helpfully warned me that I didn't have NameVirtualHost set and nothing was going to be listening on port 80. After quickly adding <code>NameVirtualHost 50.116.49.236:80</code> to my apache2.conf file, I reloaded again. I pointed my browser to www.jeffknupp.com and... saw a directory listing of my Octopress install. One quick edit to my jeffknupp.com site configuration and I was good to go. I successfully saw my Hello World post.</p>

<p>So how long did this all take? Maybe 20 minutes, and most of that was installing Ruby. I'm quite happy with the result: I now have a blogging engine "for hackers" that suits my needs perfectly.</p>
]]></content>
  </entry>
  
</feed>
